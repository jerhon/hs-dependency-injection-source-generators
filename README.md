# Honlsoft.DependencyInjection.SourceGenerators

This is a project to test out creating a source generator(s) in Roslyn.


## Constructor Source Generator


```csharp
public partial class MyClass {

    [Inject] private readonly string _paramter1;
    
    [Inject] private readonly string _paramter2;

}
```

This will create a constructor matching the following pattern.

```csharp
public MyClass(string _parameter1, string _parameter2) {
    this._parameter1 = _parameter1;
    this._parameter2 = _parameter2;
}
```


## Factory Source Generator

This project was meant to auto generate Factories for classes with constructors attributed with a `[Factory]` attribute.
The source generator would auto implement a Factory for the class.
I have a unit test that demonstrates this.

```csharp
[Test]
public void TestExecutionOfSimpleFactory() 
{
    IInstanceClassFactory factory = new InstanceClassFactory(new InjectedClass());
    var testClass = factory.Create("Factory");
    Assert.AreEqual("Factory Injected!", testClass.ToString());
}
```

Where the class that the factory is autogenerated for is here:

```csharp
public class InjectedClass {
    public override string ToString() {
        return "Injected!";
    }
}

public class InstanceClass {

    private readonly string _regularParameter;
    private readonly InjectedClass _injectedParameter;
    
    [Factory]
    public InstanceClass(string regularParameter, [Inject]InjectedClass injectedClass) {
        _regularParameter = regularParameter;
        _injectedParameter = injectedClass;
    }

    public override string ToString() {
        return $"{_regularParameter} {_injectedParameter}";
    }
}
```

I want to use the Factory pattern in order to create a class which has some constructor parameters which are dependencies that would be injected by say an DI container, and the others are not available until runtime.


## Interface Source Generator (TBD)

This is TBD, but would generate an interface based off the class.  Useful for DI and unit testing.

```csharp
[Interface]
public class MyClass {

    [Interface]
    public void Method() {
    }
    
    [Interface]
    public void Method2() {
    }
}
```


```csharp
public interface IMyClass {
    public void Method();
    public void Method2();
}
```

Can then DI in the interface, and use it for mocking while unit testing.

## Combine `[Inject]` and `[Factory]` at the class level (TBD)

Add the ability to auto generate a factory when auto generating a constructor.
With optional parameters provided.  Allow combining the interface as well.


## Problems

* Debugging is clunky, and I haven't found an easy way to output log/debug/trace information from my source generator.

### ISourceGenerator should not have shared variables

Originally I had limited success.

While I was able to generate a factory, the editing experience in Rider and Visual Studio isn't working to my satisfaction.
Full builds and rebuilds of the solution would work fine.  However, editing in the project would cause the generated source to be lost and I would start getting errors that the generated factories don't exist.

These could be issues with my source generator, but I need to investigate it further.

Reading through this a common problem is having a shared field or property across execution runs: https://github.com/dotnet/roslyn/issues/49249
The intent is that every time execute is run, it should not share state as it can be run multi-threaded!
This ca

## TODO

If I can figure out the problem above, there are several todos:
* Cleanup - this was a try it out kind of project, and the code base could be a little cleaner
* Add a LOT more tests.
* Add errors around situations where the syntax is not supported.
